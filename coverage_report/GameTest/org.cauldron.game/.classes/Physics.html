


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: Physics</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">org.cauldron.game</a> ]
</div>

<h1>Coverage Summary for Class: Physics (org.cauldron.game)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Physics</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/ 1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (20/ 24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94%
  </span>
  <span class="absValue">
    (218/ 232)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;package org.cauldron.game;
<i>2</i>&nbsp;
<i>3</i>&nbsp;import org.cauldron.entity.Entity;
<i>4</i>&nbsp;import org.cauldron.entity.EntityHandler;
<i>5</i>&nbsp;import org.cauldron.entity.PowerUpType;
<i>6</i>&nbsp;import org.cauldron.entity.components.Collision;
<i>7</i>&nbsp;import org.cauldron.entity.components.EntityPair;
<i>8</i>&nbsp;import org.cauldron.entity.entities.Crate;
<i>9</i>&nbsp;import org.cauldron.entity.entities.Projectile;
<i>10</i>&nbsp;import org.cauldron.entity.entities.Tank;
<i>11</i>&nbsp;import org.cauldron.renderer.TextureHandler;
<i>12</i>&nbsp;import org.cauldron.renderer.layers.Layer;
<i>13</i>&nbsp;import org.joml.Vector2d;
<i>14</i>&nbsp;
<i>15</i>&nbsp;import java.util.ArrayList;
<i>16</i>&nbsp;import java.util.HashSet;
<i>17</i>&nbsp;import java.util.Set;
<i>18</i>&nbsp;
<i>19</i>&nbsp;import static java.lang.Math.max;
<i>20</i>&nbsp;import static java.lang.Math.min;
<i>21</i>&nbsp;import static org.cauldron.entity.EntityType.*;
<i>22</i>&nbsp;import static org.cauldron.renderer.Renderer.COLOR.ORANGE;
<i>23</i>&nbsp;
<b class="nc"><i>24</i>&nbsp;public class Physics {</b>
<i>25</i>&nbsp;    public static final float GRAVITY = -9.81f;
<i>26</i>&nbsp;
<i>27</i>&nbsp;    private static EntityHandler entityHandler;
<i>28</i>&nbsp;
<i>29</i>&nbsp;    /**
<i>30</i>&nbsp;     * @param eh EntityHandler to process
<i>31</i>&nbsp;     * @param dt delta time or change in time
<i>32</i>&nbsp;     */
<i>33</i>&nbsp;    public static void updatePhysics(EntityHandler eh, double dt) { // dt being delta time or change in time
<b class="fc"><i>34</i>&nbsp;        entityHandler = eh;</b>
<b class="fc"><i>35</i>&nbsp;        Entity[] entities = entityHandler.getEntities();</b>
<i>36</i>&nbsp;
<i>37</i>&nbsp;        // -- Deal with collisions
<i>38</i>&nbsp;        // Borad phase
<b class="fc"><i>39</i>&nbsp;        Set&lt;EntityPair&gt; maybeCollidingPairs = getMaybeCollidingPairs(entities);</b>
<i>40</i>&nbsp;        // Narrow phase - comparing two objects at each time
<i>41</i>&nbsp;        Entity a, b;
<b class="fc"><i>42</i>&nbsp;        for (EntityPair pair : maybeCollidingPairs) {</b>
<b class="fc"><i>43</i>&nbsp;            a = pair.A;</b>
<b class="fc"><i>44</i>&nbsp;            b = pair.B;</b>
<b class="fc"><i>45</i>&nbsp;            Collision collision = colliding(a, b);</b>
<b class="fc"><i>46</i>&nbsp;            if (collision.colliding) {</b>
<b class="fc"><i>47</i>&nbsp;                Entity[] resolvedCol = resolveCollision(a, b, collision.colNormal);</b>
<b class="fc"><i>48</i>&nbsp;                if (resolvedCol == null)</b>
<b class="fc"><i>49</i>&nbsp;                    continue;</b>
<i>50</i>&nbsp;            }
<b class="fc"><i>51</i>&nbsp;        }</b>
<i>52</i>&nbsp;
<i>53</i>&nbsp;        // -- step objects
<i>54</i>&nbsp;        //update object velocities and positions according to their force and mass
<b class="fc"><i>55</i>&nbsp;        for (Entity entity : entities) {</b>
<i>56</i>&nbsp;            // Simplistic Euler
<i>57</i>&nbsp;            // acceleration is calculated by force divided my mass; or inverse force multiplied by mass
<b class="fc"><i>58</i>&nbsp;            if (entity == null || entity.type == GROUND || entity.type == TURRET)</b>
<b class="fc"><i>59</i>&nbsp;                continue;</b>
<b class="fc"><i>60</i>&nbsp;            if (entity.type != PROJECTILE &amp;&amp; entity.type != PARTICLE) {</b>
<b class="fc"><i>61</i>&nbsp;                entity.updateNormal();</b>
<b class="fc"><i>62</i>&nbsp;                entity.updateFriction();</b>
<i>63</i>&nbsp;            }
<b class="fc"><i>64</i>&nbsp;            if (entity.type == PROJECTILE) {</b>
<b class="fc"><i>65</i>&nbsp;                if (((Projectile) entity).guided) {</b>
<b class="fc"><i>66</i>&nbsp;                    guideMissile((Projectile) entity, dt);</b>
<i>67</i>&nbsp;                }
<i>68</i>&nbsp;            }
<b class="fc"><i>69</i>&nbsp;            Vector2d newPos = new Vector2d(entity.position).add(new Vector2d(entity.velocity).mul((float) (dt / (double) 1000f)));</b>
<b class="fc"><i>70</i>&nbsp;            if (entity.type != PROJECTILE || !((Projectile) entity).guided) { // we don&#39;t want guided missiles to be effected by gravity</b>
<b class="fc"><i>71</i>&nbsp;                entity.velocity.add(new Vector2d(entity.getResultant()).mul((float) ((double) 1f / entity.mass.mass * dt / (double) 1000f)));</b>
<i>72</i>&nbsp;            }
<b class="fc"><i>73</i>&nbsp;            if (!outOfPlay(newPos, entity) || entity.type != TANK)</b>
<b class="fc"><i>74</i>&nbsp;                entity.position.set(newPos);</b>
<i>75</i>&nbsp;            else
<b class="fc"><i>76</i>&nbsp;                entity.velocity = new Vector2d(0, 0);</b>
<i>77</i>&nbsp;        }
<i>78</i>&nbsp;
<i>79</i>&nbsp;        // -- game logic
<i>80</i>&nbsp;        // move tanks on death and update time alive.
<b class="fc"><i>81</i>&nbsp;        for (Entity entity : entities) {</b>
<b class="fc"><i>82</i>&nbsp;            if (entity != null &amp;&amp; entity.type == TANK) {</b>
<b class="fc"><i>83</i>&nbsp;                tankGameLogic((Tank) entity, eh);</b>
<i>84</i>&nbsp;            }
<i>85</i>&nbsp;        }
<i>86</i>&nbsp;    }
<i>87</i>&nbsp;
<i>88</i>&nbsp;    private static void tankGameLogic(Tank tank, EntityHandler eh) {
<b class="fc"><i>89</i>&nbsp;        if (tank.health &lt;= 0) {</b>
<b class="fc"><i>90</i>&nbsp;            dealWithDeadTank(tank, eh);</b>
<i>91</i>&nbsp;        } else {
<b class="fc"><i>92</i>&nbsp;            if (tank.stats.currentTimeAlive() &gt; tank.stats.longestTimeAlive) {</b>
<b class="fc"><i>93</i>&nbsp;                tank.stats.longestTimeAlive = tank.stats.currentTimeAlive();</b>
<i>94</i>&nbsp;            }
<i>95</i>&nbsp;        }
<i>96</i>&nbsp;    }
<i>97</i>&nbsp;
<i>98</i>&nbsp;    /**
<i>99</i>&nbsp;     * deals with tanks that have a health of 0 or below.
<i>100</i>&nbsp;     * it will clear their powerups, move it to a random x position, create an explosion of where the tank was and then update the score for the other team.
<i>101</i>&nbsp;     *
<i>102</i>&nbsp;     * @param tank the tank
<i>103</i>&nbsp;     * @param eh   the EntityHandler
<i>104</i>&nbsp;     */
<i>105</i>&nbsp;    private static void dealWithDeadTank(Tank tank, EntityHandler eh) {
<b class="fc"><i>106</i>&nbsp;        tank.lives -= 1;</b>
<b class="fc"><i>107</i>&nbsp;        tank.stats.deaths += 1;</b>
<b class="fc"><i>108</i>&nbsp;        tank.stats.mostRecentDeath = System.currentTimeMillis();</b>
<b class="fc"><i>109</i>&nbsp;        tank.stats.currentKillStreak = 0;</b>
<b class="fc"><i>110</i>&nbsp;        tank.health = tank.maxHealth;</b>
<i>111</i>&nbsp;        //removes powerups from tank
<b class="fc"><i>112</i>&nbsp;        tank.appliedPowerUps.clear();</b>
<i>113</i>&nbsp;        //sets tank position to random place on screen not within 300 of current location
<b class="fc"><i>114</i>&nbsp;        int randX = 50 + (int) ((Layer.WIDTH - 100) * Math.random());</b>
<b class="fc"><i>115</i>&nbsp;        while (Math.abs(randX - tank.position.x) &lt; 300) {</b>
<b class="fc"><i>116</i>&nbsp;            randX = 50 + (int) ((Layer.WIDTH - 100) * Math.random());</b>
<i>117</i>&nbsp;        }
<b class="fc"><i>118</i>&nbsp;        eh.createExplosion((float) tank.position.x + (float) tank.position.x / 2f, (float) tank.position.y + (float) tank.position.y / 4f, 10, 200, ORANGE);</b>
<b class="fc"><i>119</i>&nbsp;        tank.position.x = randX;</b>
<i>120</i>&nbsp;
<i>121</i>&nbsp;        // teams scores held in EntityHandler
<b class="fc"><i>122</i>&nbsp;        for (int i = 0; i &lt; eh.teamsList.size(); i++) {</b>
<b class="fc"><i>123</i>&nbsp;            if (eh.teamsList.get(i).contains(tank.name)) {</b>
<b class="fc"><i>124</i>&nbsp;                System.out.println(tank.name);</b>
<b class="fc"><i>125</i>&nbsp;                if (i == 0) {</b>
<b class="fc"><i>126</i>&nbsp;                    eh.scores[1]++;</b>
<i>127</i>&nbsp;                } else
<b class="fc"><i>128</i>&nbsp;                    eh.scores[0]++;</b>
<i>129</i>&nbsp;            }
<i>130</i>&nbsp;        }
<i>131</i>&nbsp;    }
<i>132</i>&nbsp;
<i>133</i>&nbsp;    /**
<i>134</i>&nbsp;     * for when a player has used the guided projectile powerup when firing a projectile, this is the method that will guide it towards the target.
<i>135</i>&nbsp;     * In order for the guiding of the projectile to look natural, like a real guided missile you cannot simply have it travel towards the target. you must instead change the angle that it travelling at so that it appears to turn towards it&#39;s target.
<i>136</i>&nbsp;     * I tried playing around with the rate of change of the angle and settled at using the modifier: (dt/300)
<i>137</i>&nbsp;     * &lt;p&gt;
<i>138</i>&nbsp;     * I tested having the missile lock onto the target entity but the game was more fun if you were still able to dodge the guided projectile by moving away from where you were when it fired.
<i>139</i>&nbsp;     *
<i>140</i>&nbsp;     * @param projectile the projectile to be guided
<i>141</i>&nbsp;     * @param dt         change in time (in milliseconds)
<i>142</i>&nbsp;     */
<i>143</i>&nbsp;    private static void guideMissile(Projectile projectile, double dt) {
<b class="fc"><i>144</i>&nbsp;        Vector2d origTargetPos = projectile.target;</b>
<b class="fc"><i>145</i>&nbsp;        Vector2d targetPos = new Vector2d(origTargetPos.x, origTargetPos.y);</b>
<b class="fc"><i>146</i>&nbsp;        Vector2d currentPos = projectile.position;</b>
<b class="fc"><i>147</i>&nbsp;        Vector2d currentVelocity = projectile.velocity;</b>
<b class="fc"><i>148</i>&nbsp;        Vector2d relativeTargetPos = targetPos.sub(currentPos);</b>
<b class="fc"><i>149</i>&nbsp;        Double cross = (currentVelocity.x * relativeTargetPos.y) - (currentVelocity.y * relativeTargetPos.x);</b>
<b class="fc"><i>150</i>&nbsp;        if (cross &lt; 0) {</b>
<i>151</i>&nbsp;            // turn clockwise
<b class="fc"><i>152</i>&nbsp;            projectile.velocity = rotate(currentVelocity, -1 * (dt / 300));</b>
<i>153</i>&nbsp;        } else {
<i>154</i>&nbsp;            // turn anti-clockwise
<b class="fc"><i>155</i>&nbsp;            projectile.velocity = rotate(currentVelocity, 1 * (dt / 300));</b>
<i>156</i>&nbsp;        }
<i>157</i>&nbsp;    }
<i>158</i>&nbsp;
<i>159</i>&nbsp;    /**
<i>160</i>&nbsp;     * rotates a vector a number of radians
<i>161</i>&nbsp;     *
<i>162</i>&nbsp;     * @param vec the original vector
<i>163</i>&nbsp;     * @param n   the number of radians to rotate the vector
<i>164</i>&nbsp;     * @return the new rotated vector
<i>165</i>&nbsp;     */
<i>166</i>&nbsp;    private static Vector2d rotate(Vector2d vec, double n) {
<b class="fc"><i>167</i>&nbsp;        double newx = (vec.x * Math.cos(n)) - (vec.y * Math.sin(n));</b>
<b class="fc"><i>168</i>&nbsp;        double newy = (vec.x * Math.sin(n)) + (vec.y * Math.cos(n));</b>
<b class="fc"><i>169</i>&nbsp;        return new Vector2d(newx, newy);</b>
<i>170</i>&nbsp;    }
<i>171</i>&nbsp;
<i>172</i>&nbsp;    /**
<i>173</i>&nbsp;     * tests if an entity is out of play, using Layer.HEIGHT and layer.WIDTH
<i>174</i>&nbsp;     *
<i>175</i>&nbsp;     * @param pos    the position to test for the entity
<i>176</i>&nbsp;     * @param entity we need this entity to be able to get the width of it.
<i>177</i>&nbsp;     * @return true if it is out of play, or false if it is still in play.
<i>178</i>&nbsp;     */
<i>179</i>&nbsp;    private static boolean outOfPlay(Vector2d pos, Entity entity) {
<b class="fc"><i>180</i>&nbsp;        return (int) (pos.x + entity.shape.width) &gt; Layer.WIDTH || (int) pos.x &lt; 0 || (int) (pos.y + entity.shape.height) &gt; Layer.HEIGHT || (int) pos.y &lt; 0;</b>
<i>181</i>&nbsp;    }
<i>182</i>&nbsp;
<i>183</i>&nbsp;    /**
<i>184</i>&nbsp;     * When a collision happens this method is ran, here is where we define the gameplay effects of collisions between certain entities
<i>185</i>&nbsp;     * &lt;p&gt;
<i>186</i>&nbsp;     * e.g. causing damage to a tank hit by a projectile or causing two projectiles to explode if they collide in mid air.
<i>187</i>&nbsp;     * &lt;p&gt;
<i>188</i>&nbsp;     * This method is ran twice, with a and b swapped the second time so that we can minimise code.
<i>189</i>&nbsp;     *
<i>190</i>&nbsp;     * @param a      the first entity
<i>191</i>&nbsp;     * @param b      the second entity
<i>192</i>&nbsp;     * @param normal the collision normal
<i>193</i>&nbsp;     */
<i>194</i>&nbsp;    private static void resolveSpecificCases(Entity a, Entity b, Vector2d normal) {
<i>195</i>&nbsp;        Tank tank;
<i>196</i>&nbsp;        //// handle collisions between tank and projectile
<i>197</i>&nbsp;        //apply hit to tank if other was projectile
<b class="pc"><i>198</i>&nbsp;        if (a.type == TANK &amp;&amp; b.type == PROJECTILE &amp;&amp; !isFriendlyFire(a, b, entityHandler.teamsList)) {</b>
<b class="fc"><i>199</i>&nbsp;            tank = (Tank) a;</b>
<b class="fc"><i>200</i>&nbsp;            tank.stats.hitsTaken += 1;</b>
<b class="fc"><i>201</i>&nbsp;            ((Tank) (entityHandler.getEntity(b.parent))).stats.shotsHitTarget += 1;</b>
<b class="pc"><i>202</i>&nbsp;            if (tank.hasPowerUp(PowerUpType.SHIELD)) {</b>
<b class="nc"><i>203</i>&nbsp;                tank.health -= ((Projectile) b).damage / 2;</b>
<i>204</i>&nbsp;            } else {
<b class="fc"><i>205</i>&nbsp;                tank.health -= ((Projectile) b).damage;</b>
<i>206</i>&nbsp;            }
<b class="fc"><i>207</i>&nbsp;            System.out.println(tank.name + &quot; taken &quot; + tank.stats.hitsTaken + &quot; hits! and health: &quot; + tank.health);</b>
<b class="fc"><i>208</i>&nbsp;            a = tank;</b>
<b class="fc"><i>209</i>&nbsp;            entityHandler.createExplosion((float) b.position.x, (float) b.position.y, (float) new Vector2d(normal.x, 0).angle(new Vector2d(0, normal.y)), 10, 200, ORANGE);</b>
<b class="fc"><i>210</i>&nbsp;            b.position.x = -100; //removes the projectile</b>
<b class="fc"><i>211</i>&nbsp;            ((Projectile) b).guided = false;</b>
<b class="fc"><i>212</i>&nbsp;            if (tank.health &lt;= 0) {</b>
<b class="fc"><i>213</i>&nbsp;                ((Tank) (entityHandler.getEntity(b.parent))).stats.killedPlayerUpdate();</b>
<i>214</i>&nbsp;            }
<i>215</i>&nbsp;        }
<i>216</i>&nbsp;
<i>217</i>&nbsp;        //// handle collisions between ground and projectile
<b class="fc"><i>218</i>&nbsp;        if (a.type == GROUND &amp;&amp; b.type == PROJECTILE) {</b>
<b class="fc"><i>219</i>&nbsp;            entityHandler.createExplosion((float) b.position.x, (float) b.position.y + 5, 90, 10, 200, ORANGE);</b>
<b class="fc"><i>220</i>&nbsp;            b.position.x = -100; //removes the projectile</b>
<b class="fc"><i>221</i>&nbsp;            ((Projectile) b).guided = false;</b>
<i>222</i>&nbsp;        }
<i>223</i>&nbsp;
<b class="fc"><i>224</i>&nbsp;        if (a.type == GROUND &amp;&amp; b.type == PARTICLE) {</b>
<b class="fc"><i>225</i>&nbsp;            b.position.x = -100; //removes the projectile</b>
<i>226</i>&nbsp;        }
<i>227</i>&nbsp;
<b class="pc"><i>228</i>&nbsp;        if (a.type == PROJECTILE &amp;&amp; b.type == PROJECTILE) {</b>
<i>229</i>&nbsp;            //check they have different parents so cluster shots work
<b class="nc"><i>230</i>&nbsp;            if (((Projectile) a).parent != ((Projectile) b).parent) {</b>
<b class="nc"><i>231</i>&nbsp;                entityHandler.createExplosion((float) b.position.x, (float) b.position.y + 10, 10, 200, ORANGE);</b>
<b class="nc"><i>232</i>&nbsp;                a.position.x = -100; //removes the projectile</b>
<b class="nc"><i>233</i>&nbsp;                ((Projectile) a).guided = false;</b>
<b class="nc"><i>234</i>&nbsp;                b.position.x = -100; //removes the projectile</b>
<b class="nc"><i>235</i>&nbsp;                ((Projectile) b).guided = false;</b>
<i>236</i>&nbsp;            }
<i>237</i>&nbsp;        }
<i>238</i>&nbsp;
<i>239</i>&nbsp;        //// handle collisions between projectile and crate
<i>240</i>&nbsp;        Crate crate;
<b class="fc"><i>241</i>&nbsp;        if (a.type == PROJECTILE &amp;&amp; b.type == CRATE) {</b>
<i>242</i>&nbsp;            // we will give the tank a power-up. This powerup will apply for a certain duration
<b class="fc"><i>243</i>&nbsp;            tank = (Tank) entityHandler.getEntity(a.parent);</b>
<b class="fc"><i>244</i>&nbsp;            tank.stats.shotsHitTarget += 1;</b>
<b class="fc"><i>245</i>&nbsp;            crate = (Crate) b;</b>
<b class="fc"><i>246</i>&nbsp;            TextureHandler.wipeAnimation(crate);</b>
<b class="fc"><i>247</i>&nbsp;            crate.health -= ((Projectile) a).damage;</b>
<b class="fc"><i>248</i>&nbsp;            if (crate.health &lt;= 0) {</b>
<i>249</i>&nbsp;                try {
<b class="fc"><i>250</i>&nbsp;                    entityHandler.removeEntity(crate.name);//removes the crate</b>
<b class="fc"><i>251</i>&nbsp;                    entityHandler.applyPowerUp(tank, crate.powerUpType);</b>
<b class="fc"><i>252</i>&nbsp;                    tank.stats.crates += 1;</b>
<b class="nc"><i>253</i>&nbsp;                } catch (java.lang.NullPointerException e) {</b>
<b class="nc"><i>254</i>&nbsp;                    System.out.println((&quot;looks like the crate has already been removed! So I didn&#39;t apply the powerup!&quot;));</b>
<b class="fc"><i>255</i>&nbsp;                }</b>
<i>256</i>&nbsp;            }
<b class="fc"><i>257</i>&nbsp;            entityHandler.createExplosion((float) a.position.x, (float) a.position.y, (float) new Vector2d(normal.x, 0).angle(new Vector2d(0, normal.y)), 10, 200, ORANGE);</b>
<b class="fc"><i>258</i>&nbsp;            a.position.x = -100; //removes the projectile</b>
<b class="fc"><i>259</i>&nbsp;            ((Projectile) a).guided = false;</b>
<i>260</i>&nbsp;
<i>261</i>&nbsp;        }
<i>262</i>&nbsp;    }
<i>263</i>&nbsp;
<i>264</i>&nbsp;    /**
<i>265</i>&nbsp;     * resolves confirmed collisions. Will generally cause the objects to bounce away from each other.
<i>266</i>&nbsp;     * &lt;p&gt;
<i>267</i>&nbsp;     * Also runs the resolveSpecificCases() method so that game play events can happen
<i>268</i>&nbsp;     *
<i>269</i>&nbsp;     * @param a      the first entity
<i>270</i>&nbsp;     * @param b      the second entity
<i>271</i>&nbsp;     * @param normal the collision normal
<i>272</i>&nbsp;     * @return the two entities it was passed
<i>273</i>&nbsp;     */
<i>274</i>&nbsp;    private static Entity[] resolveCollision(Entity a, Entity b, Vector2d normal) {
<i>275</i>&nbsp;
<i>276</i>&nbsp;        //// handle collisions for specific cases
<b class="fc"><i>277</i>&nbsp;        resolveSpecificCases(a, b, normal);</b>
<b class="fc"><i>278</i>&nbsp;        resolveSpecificCases(b, a, normal);</b>
<i>279</i>&nbsp;
<i>280</i>&nbsp;
<i>281</i>&nbsp;        // rv = resultant velocity
<b class="fc"><i>282</i>&nbsp;        Vector2d rv = new Vector2d(b.velocity).sub(a.velocity);</b>
<i>283</i>&nbsp;        //calculate the relative velocity along the normal
<b class="fc"><i>284</i>&nbsp;        float velAlongNormal = (float) new Vector2d(rv).dot(normal);</b>
<i>285</i>&nbsp;
<i>286</i>&nbsp;        //don&#39;t resolve if velocities are separating
<b class="fc"><i>287</i>&nbsp;        if (velAlongNormal &gt; 0) {</b>
<b class="fc"><i>288</i>&nbsp;            return null;</b>
<i>289</i>&nbsp;        }
<i>290</i>&nbsp;
<i>291</i>&nbsp;        //calculate restitution
<b class="fc"><i>292</i>&nbsp;        float restitution = min(a.material.restitution, b.material.restitution);</b>
<i>293</i>&nbsp;
<i>294</i>&nbsp;        // calc impulse scalar
<b class="fc"><i>295</i>&nbsp;        float j = -(1 + restitution) * velAlongNormal;</b>
<b class="fc"><i>296</i>&nbsp;        j = j / (a.mass.invMass + b.mass.invMass);</b>
<i>297</i>&nbsp;
<i>298</i>&nbsp;        //apply impulse
<b class="fc"><i>299</i>&nbsp;        Vector2d impulse = new Vector2d(normal).mul(j);</b>
<b class="fc"><i>300</i>&nbsp;        a.velocity.sub(new Vector2d(impulse).mul(a.mass.invMass));</b>
<b class="fc"><i>301</i>&nbsp;        b.velocity.add(new Vector2d(impulse).mul(b.mass.invMass));</b>
<i>302</i>&nbsp;
<i>303</i>&nbsp;        // apply correction to fix floating point errors
<b class="fc"><i>304</i>&nbsp;        Entity[] correctedPos = positionalCorrection(a, b, normal);</b>
<b class="fc"><i>305</i>&nbsp;        a = correctedPos[0];</b>
<b class="fc"><i>306</i>&nbsp;        b = correctedPos[1];</b>
<i>307</i>&nbsp;
<i>308</i>&nbsp;        // -- apply friction
<i>309</i>&nbsp;        //solve for the tangent vector
<b class="fc"><i>310</i>&nbsp;        Vector2d tangent = new Vector2d(rv).sub(new Vector2d(normal).mul(new Vector2d(rv).dot(normal)));</b>
<b class="pc"><i>311</i>&nbsp;        if (!tangent.equals(0f, 0f))</b>
<b class="fc"><i>312</i>&nbsp;            tangent.normalize();</b>
<i>313</i>&nbsp;        //solve for magnitude to apply friction to vector
<b class="fc"><i>314</i>&nbsp;        float jt = (float) new Vector2d(rv).dot(tangent);</b>
<b class="fc"><i>315</i>&nbsp;        jt = jt / (a.mass.invMass + b.mass.invMass);</b>
<i>316</i>&nbsp;        // use pythagoras to approximate mu given friction coefficients of each body
<b class="fc"><i>317</i>&nbsp;        float mu = pythagoreanSolve(a.frictionData.staticFriction, b.frictionData.staticFriction);</b>
<i>318</i>&nbsp;        // &quot;clamp&quot; magnitude of friction and create impulse vector
<i>319</i>&nbsp;        Vector2d frictionImpulse;
<i>320</i>&nbsp;        //System.out.println(&quot;friction calc for: &quot; + a.name + &quot; &amp; &quot; + b.name);
<b class="fc"><i>321</i>&nbsp;        if (Math.abs(jt) &lt; j * mu) {</b>
<b class="fc"><i>322</i>&nbsp;            frictionImpulse = new Vector2d(tangent).mul(jt);</b>
<i>323</i>&nbsp;            //System.out.println(&quot;friction was clamped at min of:&quot; + frictionImpulse.toString());
<i>324</i>&nbsp;        } else {
<b class="fc"><i>325</i>&nbsp;            float dynamicFriction = pythagoreanSolve(a.frictionData.dynamicFriction, b.frictionData.dynamicFriction);</b>
<b class="fc"><i>326</i>&nbsp;            frictionImpulse = new Vector2d(tangent).mul(-j * dynamicFriction);</b>
<i>327</i>&nbsp;            //System.out.println(&quot;friction was dynamic at:&quot; + frictionImpulse.toString());
<i>328</i>&nbsp;        }
<i>329</i>&nbsp;        //apply friction
<b class="fc"><i>330</i>&nbsp;        a.velocity.sub(new Vector2d(frictionImpulse).mul(a.mass.invMass));</b>
<b class="fc"><i>331</i>&nbsp;        b.velocity.add(new Vector2d(frictionImpulse).mul(b.mass.invMass));</b>
<i>332</i>&nbsp;
<b class="fc"><i>333</i>&nbsp;        return new Entity[]{a, b};</b>
<i>334</i>&nbsp;    }
<i>335</i>&nbsp;
<i>336</i>&nbsp;    /**
<i>337</i>&nbsp;     * @param a short side 1
<i>338</i>&nbsp;     * @param b short side 2
<i>339</i>&nbsp;     * @return the hypothesis of the right angle triangle
<i>340</i>&nbsp;     */
<i>341</i>&nbsp;    private static float pythagoreanSolve(float a, float b) {
<b class="fc"><i>342</i>&nbsp;        return (float) Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));</b>
<i>343</i>&nbsp;    }
<i>344</i>&nbsp;
<i>345</i>&nbsp;    /**
<i>346</i>&nbsp;     * this stops objects sinking into each other and also reduces jittering effects
<i>347</i>&nbsp;     * &lt;p&gt;
<i>348</i>&nbsp;     * source: https://gamedevelopment.tutsplus.com/tutorials/how-to-create-a-custom-2d-physics-engine-the-basics-and-impulse-resolution--gamedev-6331
<i>349</i>&nbsp;     *
<i>350</i>&nbsp;     * @param a      first entity
<i>351</i>&nbsp;     * @param b      second entity
<i>352</i>&nbsp;     * @param normal collision normal
<i>353</i>&nbsp;     * @return the entities it was passed.
<i>354</i>&nbsp;     */
<i>355</i>&nbsp;    private static Entity[] positionalCorrection(Entity a, Entity b, Vector2d normal) {
<b class="fc"><i>356</i>&nbsp;        final float percent = 0.2f; // usually 20% to 80%</b>
<b class="fc"><i>357</i>&nbsp;        final float slop = 0.01f; // usually 0.01 to 0.1</b>
<b class="fc"><i>358</i>&nbsp;        float collisionDepth = getCollisionDepth(a, b);</b>
<b class="fc"><i>359</i>&nbsp;        Vector2d correction = new Vector2d(normal).mul(max(collisionDepth - slop, 0.0f) / (a.mass.invMass + b.mass.invMass) * percent);</b>
<b class="fc"><i>360</i>&nbsp;        a.position.sub(new Vector2d(correction).mul(a.mass.invMass));</b>
<b class="fc"><i>361</i>&nbsp;        b.position.add(new Vector2d(correction).mul(b.mass.invMass));</b>
<b class="fc"><i>362</i>&nbsp;        return new Entity[]{a, b};</b>
<i>363</i>&nbsp;    }
<i>364</i>&nbsp;
<i>365</i>&nbsp;    /**
<i>366</i>&nbsp;     * Will check if two bodies are colliding
<i>367</i>&nbsp;     *
<i>368</i>&nbsp;     * @param a first body
<i>369</i>&nbsp;     * @param b second body
<i>370</i>&nbsp;     * @return a collision data instance with the collision normal if they are colliding
<i>371</i>&nbsp;     */
<i>372</i>&nbsp;    public static Collision colliding(Entity a, Entity b) {
<i>373</i>&nbsp;        Vector2d[] myCoords;
<i>374</i>&nbsp;        Vector2d[] othersCoords;
<i>375</i>&nbsp;
<b class="fc"><i>376</i>&nbsp;        if (a.type == TURRET || b.type == TURRET) // no collisions with the turret</b>
<b class="fc"><i>377</i>&nbsp;            return new Collision(false);</b>
<b class="fc"><i>378</i>&nbsp;        if (a.type == TANK &amp;&amp; b.type == TANK) // No inter-tank collisions</b>
<b class="fc"><i>379</i>&nbsp;            return new Collision(false);</b>
<b class="fc"><i>380</i>&nbsp;        if (a.type == GROUND &amp;&amp; b.type == TANK) // For now, no collisions with the ground</b>
<b class="fc"><i>381</i>&nbsp;            return new Collision(false);</b>
<b class="fc"><i>382</i>&nbsp;        if (a.type == TANK &amp;&amp; b.type == GROUND) // For now, no collisions with the ground</b>
<b class="fc"><i>383</i>&nbsp;            return new Collision(false);</b>
<b class="fc"><i>384</i>&nbsp;        if (a.type != GROUND &amp;&amp; b.type == PARTICLE) // Particles only collide with the ground</b>
<b class="fc"><i>385</i>&nbsp;            return new Collision(false);</b>
<b class="pc"><i>386</i>&nbsp;        if (a.type == PARTICLE &amp;&amp; b.type != GROUND) // Particles only collide with the ground</b>
<b class="fc"><i>387</i>&nbsp;            return new Collision(false);</b>
<i>388</i>&nbsp;
<b class="fc"><i>389</i>&nbsp;        myCoords = a.getCornerCoords();</b>
<b class="fc"><i>390</i>&nbsp;        othersCoords = b.getCornerCoords();</b>
<i>391</i>&nbsp;
<i>392</i>&nbsp;        // quick test to see if the entities are within each other
<b class="fc"><i>393</i>&nbsp;        if (pnpoly(myCoords, othersCoords[0]) || pnpoly(othersCoords, myCoords[0])) {</b>
<b class="fc"><i>394</i>&nbsp;            return new Collision(true);</b>
<i>395</i>&nbsp;        }
<i>396</i>&nbsp;        float x, y;
<i>397</i>&nbsp;        //tests if the edges of the entities overlap
<b class="fc"><i>398</i>&nbsp;        for (int i = 0; i &lt; myCoords.length; i++) {</b>
<b class="fc"><i>399</i>&nbsp;            for (int j = 0; j &lt; othersCoords.length; j++) {</b>
<b class="fc"><i>400</i>&nbsp;                if (checkLineIntersection(myCoords[i], myCoords[(i + 1) % myCoords.length], othersCoords[j], othersCoords[(j + 1) % othersCoords.length])) {</b>
<i>401</i>&nbsp;
<b class="fc"><i>402</i>&nbsp;                    x = (float) (myCoords[i].x - myCoords[(i + 1) % myCoords.length].x); // if this doesnt work then try using othersCoords</b>
<b class="fc"><i>403</i>&nbsp;                    y = (float) (myCoords[i].y - myCoords[(i + 1) % myCoords.length].y);</b>
<i>404</i>&nbsp;
<i>405</i>&nbsp;                    //noinspection SuspiciousNameCombination
<b class="fc"><i>406</i>&nbsp;                    Vector2d colNormal = new Vector2d(y, -x); //swapped deliberately https://photos.app.goo.gl/2NxHBitzPghLYVMg7</b>
<b class="fc"><i>407</i>&nbsp;                    colNormal.normalize();</b>
<i>408</i>&nbsp;
<b class="fc"><i>409</i>&nbsp;                    return new Collision(true, colNormal);</b>
<i>410</i>&nbsp;
<i>411</i>&nbsp;                }
<i>412</i>&nbsp;            }
<i>413</i>&nbsp;        }
<b class="fc"><i>414</i>&nbsp;        return new Collision(false);</b>
<i>415</i>&nbsp;    }
<i>416</i>&nbsp;
<i>417</i>&nbsp;
<i>418</i>&nbsp;    /**
<i>419</i>&nbsp;     * algorithm from http://web.archive.org/web/20141127210836/http://content.gpwiki.org/index.php/Polygon_Collision
<i>420</i>&nbsp;     * one edge is a-b, the other is c-d
<i>421</i>&nbsp;     *
<i>422</i>&nbsp;     * @param a start point on first edge
<i>423</i>&nbsp;     * @param b end point on first edge
<i>424</i>&nbsp;     * @param c start point on second edge
<i>425</i>&nbsp;     * @param d end point on second edge
<i>426</i>&nbsp;     * @return true if the lines intersect.
<i>427</i>&nbsp;     */
<i>428</i>&nbsp;    private static boolean checkLineIntersection(Vector2d a, Vector2d b, Vector2d c, Vector2d d) {
<b class="fc"><i>429</i>&nbsp;        double det = determinant(new Vector2d(b).sub(a), new Vector2d(c).sub(d));</b>
<b class="fc"><i>430</i>&nbsp;        double t = determinant(new Vector2d(c).sub(a), new Vector2d(c).sub(d)) / det;</b>
<b class="fc"><i>431</i>&nbsp;        double u = determinant(new Vector2d(b).sub(a), new Vector2d(c).sub(a)) / det;</b>
<i>432</i>&nbsp;        //noinspection RedundantIfStatement
<b class="fc"><i>433</i>&nbsp;        if ((t &lt; 0) || (u &lt; 0) || (t &gt; 1) || (u &gt; 1) || (det == 0)) {</b>
<b class="fc"><i>434</i>&nbsp;            return false;</b>
<i>435</i>&nbsp;        } else {
<b class="fc"><i>436</i>&nbsp;            return true; // the intersection point is: a * (1 - t) + t * b</b>
<i>437</i>&nbsp;        }
<i>438</i>&nbsp;    }
<i>439</i>&nbsp;
<i>440</i>&nbsp;    /**
<i>441</i>&nbsp;     * @param c1
<i>442</i>&nbsp;     * @param c2
<i>443</i>&nbsp;     * @return the determinant of the two vectors.
<i>444</i>&nbsp;     */
<i>445</i>&nbsp;    private static double determinant(Vector2d c1, Vector2d c2) {
<b class="fc"><i>446</i>&nbsp;        return c1.x * c2.y - c1.y * c2.x;</b>
<i>447</i>&nbsp;    }
<i>448</i>&nbsp;
<i>449</i>&nbsp;
<i>450</i>&nbsp;    /**
<i>451</i>&nbsp;     * code modified from https://stackoverflow.com/a/24365675
<i>452</i>&nbsp;     * tests if a single coord is in a convex polygon made of multiple coordinates (verts)
<i>453</i>&nbsp;     *
<i>454</i>&nbsp;     * @param verts
<i>455</i>&nbsp;     * @param testCoord
<i>456</i>&nbsp;     * @return true if the vector testCoord is within the convex polygon made of the verts.
<i>457</i>&nbsp;     */
<i>458</i>&nbsp;    private static boolean pnpoly(Vector2d[] verts, Vector2d testCoord) {
<b class="fc"><i>459</i>&nbsp;        double testx = testCoord.x;</b>
<b class="fc"><i>460</i>&nbsp;        double testy = testCoord.y;</b>
<b class="fc"><i>461</i>&nbsp;        int nvert = verts.length;</b>
<i>462</i>&nbsp;        int i, j;
<b class="fc"><i>463</i>&nbsp;        boolean c = false;</b>
<b class="fc"><i>464</i>&nbsp;        for (i = 0, j = nvert - 1; i &lt; nvert; j = i++) {</b>
<b class="fc"><i>465</i>&nbsp;            if (((verts[i].y &gt; testy) != (verts[j].y &gt; testy)) &amp;&amp;</b>
<i>466</i>&nbsp;                    (testx &lt; (verts[j].x - verts[i].x) * (testy - verts[i].y) / (verts[j].y - verts[i].y) + verts[i].x))
<b class="fc"><i>467</i>&nbsp;                c = !c;</b>
<i>468</i>&nbsp;        }
<b class="fc"><i>469</i>&nbsp;        return c;</b>
<i>470</i>&nbsp;    }
<i>471</i>&nbsp;
<i>472</i>&nbsp;
<i>473</i>&nbsp;    /**
<i>474</i>&nbsp;     * @param a first body
<i>475</i>&nbsp;     * @param b second body
<i>476</i>&nbsp;     * @return collision depth for the two bodies
<i>477</i>&nbsp;     */
<i>478</i>&nbsp;    private static float getCollisionDepth(Entity a, Entity b) {
<i>479</i>&nbsp;        //TODO make this return the actual collision depth
<b class="fc"><i>480</i>&nbsp;        return 10f;</b>
<i>481</i>&nbsp;    }
<i>482</i>&nbsp;
<i>483</i>&nbsp;    /**
<i>484</i>&nbsp;     * @param entities list of bodies to check
<i>485</i>&nbsp;     * @return a bunch of possible collisions and store them in pair structures
<i>486</i>&nbsp;     */
<i>487</i>&nbsp;    private static Set&lt;EntityPair&gt; getMaybeCollidingPairs(Entity[] entities) {
<b class="fc"><i>488</i>&nbsp;        Set&lt;EntityPair&gt; maybePairs = new HashSet&lt;EntityPair&gt;();</b>
<b class="fc"><i>489</i>&nbsp;        for (Entity a : entities) {</b>
<b class="fc"><i>490</i>&nbsp;            if (a == null)</b>
<b class="fc"><i>491</i>&nbsp;                continue;</b>
<b class="fc"><i>492</i>&nbsp;            for (Entity b : entities) {</b>
<b class="fc"><i>493</i>&nbsp;                if (b == null)</b>
<b class="fc"><i>494</i>&nbsp;                    continue;</b>
<b class="fc"><i>495</i>&nbsp;                if (a == b)</b>
<b class="fc"><i>496</i>&nbsp;                    continue;</b>
<b class="pc"><i>497</i>&nbsp;                if (checkIfNear(a, b) &amp;&amp; !(a == b)) {</b>
<b class="pc"><i>498</i>&nbsp;                    if (!(maybePairs.contains(new EntityPair(a, b))) &amp;&amp; !(maybePairs.contains(new EntityPair(b, a)))) {</b>
<b class="fc"><i>499</i>&nbsp;                        maybePairs.add(new EntityPair(a, b));</b>
<i>500</i>&nbsp;                    }
<i>501</i>&nbsp;                }
<i>502</i>&nbsp;            }
<i>503</i>&nbsp;        }
<b class="fc"><i>504</i>&nbsp;        return maybePairs;</b>
<i>505</i>&nbsp;    }
<i>506</i>&nbsp;
<i>507</i>&nbsp;
<i>508</i>&nbsp;    public static float getMagnitude(Vector2d v) {
<b class="nc"><i>509</i>&nbsp;        return (float) Math.sqrt(Math.pow(v.x, 2) + Math.pow(v.y, 2));</b>
<i>510</i>&nbsp;    }
<i>511</i>&nbsp;
<i>512</i>&nbsp;    public static float getDegrees(Vector2d v) {
<b class="nc"><i>513</i>&nbsp;        return (float) Math.toDegrees(Math.atan(v.y / v.x));</b>
<i>514</i>&nbsp;    }
<i>515</i>&nbsp;
<i>516</i>&nbsp;    public static float getRadians(Vector2d v) {
<b class="nc"><i>517</i>&nbsp;        return (float) Math.atan(v.y / v.x);</b>
<i>518</i>&nbsp;    }
<i>519</i>&nbsp;
<i>520</i>&nbsp;    /**
<i>521</i>&nbsp;     * Uses a heuristic to check if two bodies could possibly be colliding based on how near they are to each other.
<i>522</i>&nbsp;     * At this point we also exclude if the two objects colliding shouldn&#39;t count. e.g. if it is your own projectile.
<i>523</i>&nbsp;     *
<i>524</i>&nbsp;     * @param a first body
<i>525</i>&nbsp;     * @param b second body
<i>526</i>&nbsp;     * @return if they are near and could be colliding.
<i>527</i>&nbsp;     */
<i>528</i>&nbsp;    private static boolean checkIfNear(Entity a, Entity b) {
<i>529</i>&nbsp;        //exclude if tank just fired this projectile
<i>530</i>&nbsp;        // assume a is the tank and b is a projectile
<b class="fc"><i>531</i>&nbsp;        if (excludeIfOwnProjectile(a, b)) return false;</b>
<i>532</i>&nbsp;        // assume b is the projectile
<b class="fc"><i>533</i>&nbsp;        if (excludeIfOwnProjectile(b, a)) return false;</b>
<b class="fc"><i>534</i>&nbsp;        if (excludeIfOwnTurret(a, b)) return false;</b>
<b class="fc"><i>535</i>&nbsp;        if (excludeIfOwnTurret(b, a)) return false;</b>
<i>536</i>&nbsp;
<i>537</i>&nbsp;
<i>538</i>&nbsp;        float x1, y1, x2, y2, maxWidth1, maxWidth2, tMaxWidth;
<b class="fc"><i>539</i>&nbsp;        x1 = (float) a.position.x;</b>
<b class="fc"><i>540</i>&nbsp;        y1 = (float) a.position.y;</b>
<b class="fc"><i>541</i>&nbsp;        x2 = (float) b.position.x;</b>
<b class="fc"><i>542</i>&nbsp;        y2 = (float) b.position.y;</b>
<i>543</i>&nbsp;        // max width of shape 1
<b class="fc"><i>544</i>&nbsp;        maxWidth1 = a.shape.maxWidth;</b>
<i>545</i>&nbsp;        // max width of shape 2
<b class="fc"><i>546</i>&nbsp;        maxWidth2 = b.shape.maxWidth;</b>
<i>547</i>&nbsp;        // total max length between 2 points if objects are colliding
<b class="fc"><i>548</i>&nbsp;        tMaxWidth = maxWidth1 + maxWidth2;</b>
<i>549</i>&nbsp;        // checks if objects are near enough to be possibly colliding
<b class="fc"><i>550</i>&nbsp;        if ((x1 - tMaxWidth &lt;= x2) &amp;&amp; (x2 &lt;= x1 + tMaxWidth)) {</b>
<i>551</i>&nbsp;            //noinspection RedundantIfStatement
<b class="fc"><i>552</i>&nbsp;            if ((y1 - tMaxWidth &lt;= y2) &amp;&amp; (y2 &lt;= y1 + tMaxWidth)) {</b>
<b class="fc"><i>553</i>&nbsp;                return true;</b>
<i>554</i>&nbsp;            }
<i>555</i>&nbsp;        }
<b class="fc"><i>556</i>&nbsp;        return false;</b>
<i>557</i>&nbsp;    }
<i>558</i>&nbsp;
<i>559</i>&nbsp;    /**
<i>560</i>&nbsp;     * @param tankEntity the entity that might be a tank
<i>561</i>&nbsp;     * @param turret     the entity that might be the tank&#39;s turret
<i>562</i>&nbsp;     * @return true if the turret is owned by the tank
<i>563</i>&nbsp;     */
<i>564</i>&nbsp;    private static boolean excludeIfOwnTurret(Entity tankEntity, Entity turret) {
<b class="fc"><i>565</i>&nbsp;        if (tankEntity.type == TANK &amp;&amp; turret.type == TURRET) {</b>
<b class="fc"><i>566</i>&nbsp;            Tank tank = (Tank) tankEntity;</b>
<b class="fc"><i>567</i>&nbsp;            return tank.turret == Integer.parseInt(turret.name.split(&quot;_&quot;)[0]);</b>
<i>568</i>&nbsp;        }
<b class="fc"><i>569</i>&nbsp;        return false;</b>
<i>570</i>&nbsp;    }
<i>571</i>&nbsp;
<i>572</i>&nbsp;    /**
<i>573</i>&nbsp;     * @param tank
<i>574</i>&nbsp;     * @param projectile
<i>575</i>&nbsp;     * @return true if the projectile was fired by this tank in the last second
<i>576</i>&nbsp;     */
<i>577</i>&nbsp;    private static boolean excludeIfOwnProjectile(Entity tank, Entity projectile) {
<b class="fc"><i>578</i>&nbsp;        if (tank.type == TANK &amp;&amp; projectile.type == PROJECTILE) {</b>
<b class="fc"><i>579</i>&nbsp;            Projectile proj = (Projectile) projectile;</b>
<b class="fc"><i>580</i>&nbsp;            if (proj.parent == entityHandler.getEntityID(tank.name)) {</b>
<i>581</i>&nbsp;                //System.out.println(proj.id + &quot; was near own tank soon!&quot;);
<b class="fc"><i>582</i>&nbsp;                return proj.creationTime + 1000 &gt; System.currentTimeMillis();</b>
<i>583</i>&nbsp;            }
<i>584</i>&nbsp;        }
<b class="fc"><i>585</i>&nbsp;        return false;</b>
<i>586</i>&nbsp;    }
<i>587</i>&nbsp;
<i>588</i>&nbsp;    /**
<i>589</i>&nbsp;     * @param tank
<i>590</i>&nbsp;     * @param projectile
<i>591</i>&nbsp;     * @param teamsList  the list of lists of team members. Each list within this contains the team members of that team
<i>592</i>&nbsp;     * @return true if the projectile was fired by a team mate
<i>593</i>&nbsp;     */
<i>594</i>&nbsp;    private static boolean isFriendlyFire(Entity tank, Entity projectile, ArrayList&lt;ArrayList&lt;String&gt;&gt; teamsList) {
<b class="pc"><i>595</i>&nbsp;        if (tank.type == TANK &amp;&amp; projectile.type == PROJECTILE) {</b>
<b class="fc"><i>596</i>&nbsp;            Projectile proj = (Projectile) projectile;</b>
<b class="fc"><i>597</i>&nbsp;            for (ArrayList&lt;String&gt; teamMates : teamsList) {</b>
<b class="pc"><i>598</i>&nbsp;                if (teamMates.contains(tank.name) &amp;&amp; teamMates.contains(entityHandler.getEntity(proj.parent).name))</b>
<b class="nc"><i>599</i>&nbsp;                    return true;</b>
<b class="fc"><i>600</i>&nbsp;            }</b>
<i>601</i>&nbsp;        }
<b class="fc"><i>602</i>&nbsp;        return false;</b>
<i>603</i>&nbsp;    }
<i>604</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2020-04-15 23:11</div>
</div>
</body>
</html>
